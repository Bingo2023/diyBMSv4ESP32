
/*
  ____  ____  _  _  ____  __  __  ___
 (  _ \(_  _)( \/ )(  _ \(  \/  )/ __)
  )(_) )_)(_  \  /  ) _ < )    ( \__ \
 (____/(____) (__) (____/(_/\/\_)(___/

DIYBMS V4.0
ESP8266 MODULE

(c)2019 Stuart Pittaway

COMPILE THIS CODE USING PLATFORM.IO

LICENSE
Attribution-NonCommercial-ShareAlike 2.0 UK: England & Wales (CC BY-NC-SA 2.0 UK)
https://creativecommons.org/licenses/by-nc-sa/2.0/uk/

* Non-Commercial — You may not use the material for commercial purposes.
* Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made.
  You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
* ShareAlike — If you remix, transform, or build upon the material, you must distribute your   contributions under the same license as the original.
* No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
*/

#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include "FS.h"

#include <SPIFFS.h>
#include "time.h"

#include "defines.h"
#include "DIYBMSServer.h"
#include "EmbeddedFiles_AutoGenerated.h"
#include "EmbeddedFiles_Integrity.h"

#include "settings.h"

#include "FS.h"
#include <LITTLEFS.h>
#include "SD.h"

#include "SoftAP.h"

AsyncWebServer *DIYBMSServer::_myserver;
String DIYBMSServer::UUIDString;
String DIYBMSServer::UUIDStringLast2Chars;

fs::SDFS *DIYBMSServer::_sdcard = 0;
void (*DIYBMSServer::_sdcardaction_callback)(uint8_t action) = 0;
PacketRequestGenerator *DIYBMSServer::_prg = 0;
PacketReceiveProcessor *DIYBMSServer::_receiveProc = 0;
diybms_eeprom_settings *DIYBMSServer::_mysettings = 0;
Rules *DIYBMSServer::_rules = 0;
ControllerState *DIYBMSServer::_controlState = 0;
HAL_ESP32 *DIYBMSServer::_hal = 0;

#define REBOOT_COUNT_DOWN 2000


void DIYBMSServer::avrProgrammer(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  uint16_t filenumber;

  if (request->hasParam("file", true))
  {
    AsyncWebParameter *filenumberparam = request->getParam("file", true);
    filenumber = filenumberparam->value().toInt();
  }
  else
  {
    SendFailure(request);
    return;
  }

  AsyncResponseStream *response = request->beginResponseStream("application/json");
  StaticJsonDocument<500> doc;

  if (_sd_card_installed)
  {
    doc["message"] = "Failed: Unable to program AVR whilst SD Card is mounted";
    serializeJson(doc, *response);
    request->send(response);
    return;
  }

  if (!_avrsettings.programmingModeEnabled)
  {
    doc["message"] = "Failed: Programming mode not enabled";
    serializeJson(doc, *response);
    request->send(response);
    return;
  }

  String manifestfilename = String("/avr/manifest.json");

  if (LITTLEFS.exists(manifestfilename))
  {
    StaticJsonDocument<3000> jsonmanifest;
    File file = LITTLEFS.open(manifestfilename);
    DeserializationError error = deserializeJson(jsonmanifest, file);
    if (error != DeserializationError::Ok)
    {
      ESP_LOGE(TAG, "Error deserialize Json");
      SendFailure(request);
      return;
    }
    else
    {
      // File open
      //ESP_LOGI(TAG, "Loaded manifest.json");

      JsonArray toplevel = jsonmanifest["avrprog"];

      int arraySize = jsonmanifest["avrprog"].size();

      if (filenumber > arraySize)
      {
        ESP_LOGE(TAG, "Index outsize array %i > %i", filenumber, arraySize);
        SendFailure(request);
        return;
      }

      JsonObject x = toplevel[filenumber];

      //serializeJsonPretty(x, SERIAL_DEBUG);

      _avrsettings.efuse = strtoul(x["efuse"].as<String>().c_str(), nullptr, 16);
      _avrsettings.hfuse = strtoul(x["hfuse"].as<String>().c_str(), nullptr, 16);
      _avrsettings.lfuse = strtoul(x["lfuse"].as<String>().c_str(), nullptr, 16);
      _avrsettings.mcu = strtoul(x["mcu"].as<String>().c_str(), nullptr, 16);

      String avrfilename = String("/avr/") + x["name"].as<String>();

      avrfilename.toCharArray(_avrsettings.filename, sizeof(_avrsettings.filename));
    }
    file.close();

    _avrsettings.progresult = 0xFF;
    _avrsettings.inProgress = true;

    //Fire task to start the AVR programming
    xTaskNotify(avrprog_task_handle, 0x00, eNotifyAction::eNoAction);
  }
  else
  {
    //No files!
    SendFailure(request);
    return;
  }

  doc["started"] = 1;
  doc["message"] = "Started";

  serializeJson(doc, *response);
  request->send(response);
}




void DIYBMSServer::saveVictron(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("VictronEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("VictronEnabled", true);
    _mysettings->VictronEnabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    _mysettings->VictronEnabled = false;
  }

  for (int i = 0; i < 3; i++)
  {
    String name = "cvl";
    name = name + i;
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      _mysettings->cvl[i] = p1->value().toFloat() * 10;
    }

    name = "ccl";
    name = name + i;
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      _mysettings->ccl[i] = p1->value().toFloat() * 10;
    }

    name = "dcl";
    name = name + i;
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      _mysettings->dcl[i] = p1->value().toFloat() * 10;
    }
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveCurrentMonRelay(AsyncWebServerRequest *request)
{
  
}
void DIYBMSServer::saveCurrentMonAdvanced(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  currentmonitoring_struct newvalues;
  //Set everything to zero/false
  memset(&newvalues, 0, sizeof(currentmonitoring_struct));

  if (request->hasParam("cmcalibration", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmcalibration", true);
    newvalues.modbus.shuntcal = p1->value().toInt();
  }
  if (request->hasParam("cmtemplimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmtemplimit", true);
    newvalues.modbus.temperaturelimit = (int16_t)(p1->value().toInt());
  }
  if (request->hasParam("cmundervlimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmundervlimit", true);
    newvalues.modbus.undervoltagelimit = p1->value().toFloat();
  }
  if (request->hasParam("cmovervlimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmovervlimit", true);
    newvalues.modbus.overvoltagelimit = p1->value().toFloat();
  }
  if (request->hasParam("cmoverclimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmoverclimit", true);
    newvalues.modbus.overcurrentlimit = p1->value().toFloat();
  }
  if (request->hasParam("cmunderclimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmunderclimit", true);
    newvalues.modbus.undercurrentlimit = p1->value().toFloat();
  }
  if (request->hasParam("cmoverplimit", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmoverplimit", true);
    newvalues.modbus.overpowerlimit = p1->value().toFloat();
  }
  if (request->hasParam("cmtempcoeff", true))
  {
    AsyncWebParameter *p1 = request->getParam("cmtempcoeff", true);
    newvalues.modbus.shunttempcoefficient = p1->value().toInt();
  }

  CurrentMonitorSetAdvancedSettings(newvalues);

  SendSuccess(request);
}

void DIYBMSServer::saveCurrentMonBasic(AsyncWebServerRequest *request)
{

}

void DIYBMSServer::saveCurrentMonSettings(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  if (request->hasParam("CurrentMonEnabled", true))
  {
    AsyncWebParameter *p1 = request->getParam("CurrentMonEnabled", true);
    _mysettings->currentMonitoringEnabled = p1->value().equals("on") ? true : false;
  }
  else
  {
    //If the parameter isn't there its FALSE/unchecked
    _mysettings->currentMonitoringEnabled = false;
  }

  if (request->hasParam("modbusAddress", true))
  {
    AsyncWebParameter *p1 = request->getParam("modbusAddress", true);
    _mysettings->currentMonitoringModBusAddress = p1->value().toInt();
  }

  if (_mysettings->currentMonitoringEnabled == false)
  {
    //Switch off current monitor, clear out the values
    memset(&currentMonitor, 0, sizeof(currentmonitoring_struct));
    currentMonitor.validReadings = false;
  }

  saveConfiguration();

  SendSuccess(request);
}

void DIYBMSServer::saveRuleConfiguration(AsyncWebServerRequest *request)
{
  if (!validateXSS(request))
    return;

  //relaytype
  for (int i = 0; i < RELAY_TOTAL; i++)
  {
    String name = "relaytype";
    name = name + (i + 1);
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      //Default
      RelayType oldValue = _mysettings->relaytype[i];
      if (p1->value().equals("Pulse"))
      {
        _mysettings->relaytype[i] = RelayType::RELAY_PULSE;
      }
      else
      {
        _mysettings->relaytype[i] = RelayType::RELAY_STANDARD;
      }

      if (oldValue != _mysettings->relaytype[i])
      {
        //The type of relay has changed - we probably need to reset something here
        ESP_LOGI(TAG, "Type of relay has changed");
        previousRelayState[i] = RelayState::RELAY_X;
      }
    }
  }

  //Relay default
  for (int i = 0; i < RELAY_TOTAL; i++)
  {
    String name = "defaultrelay";
    name = name + (i + 1);
    if (request->hasParam(name.c_str(), true, false))
    {
      AsyncWebParameter *p1 = request->getParam(name.c_str(), true, false);
      //Default
      _mysettings->rulerelaydefault[i] = RelayState::RELAY_OFF;
      if (p1->value().equals("On"))
      {
        _mysettings->rulerelaydefault[i] = RelayState::RELAY_ON;
      }
    }
  }

  for (int rule = 0; rule < RELAY_RULES; rule++)
  {

    //TODO: This STRING doesnt work properly if its on a single line!
    String name = "rule";
    name = name + (rule);
    name = name + "value";

    if (request->hasParam(name, true))
    {
      AsyncWebParameter *p1 = request->getParam(name, true);
      _mysettings->rulevalue[rule] = p1->value().toInt();
    }

    //TODO: This STRING doesnt work properly if its on a single line!
    String hname = "rule";
    hname = hname + (rule);
    hname = hname + "hysteresis";
    if (request->hasParam(hname, true))
    {
      AsyncWebParameter *p1 = request->getParam(hname, true);
      _mysettings->rulehysteresis[rule] = p1->value().toInt();
    }

    //Rule/relay processing
    for (int i = 0; i < RELAY_TOTAL; i++)
    {
      //TODO: This STRING doesnt work properly if its on a single line!
      String name = "rule";
      name = name + (rule);
      name = name + "relay";
      name = name + (i + 1);
      if (request->hasParam(name, true))
      {
        AsyncWebParameter *p1 = request->getParam(name, true);
        _mysettings->rulerelaystate[rule][i] = p1->value().equals("X") ? RELAY_X : p1->value().equals("On") ? RelayState::RELAY_ON
                                                                                                            : RelayState::RELAY_OFF;
      }
    }

    //Reset state of rules after updating the new values
    for (int8_t r = 0; r < RELAY_RULES; r++)
    {
      _rules->rule_outcome[r] = false;
    }
  }

  saveConfiguration();

  SendSuccess(request);
}


  
   
  
  _myserver->on("/savestorage.json", HTTP_POST, DIYBMSServer::saveStorage);

  _myserver->on("/resetcounters.json", HTTP_POST, DIYBMSServer::resetCounters);
  

  _myserver->on("/sdmount.json", HTTP_POST, DIYBMSServer::sdMount);
  _myserver->on("/sdunmount.json", HTTP_POST, DIYBMSServer::sdUnmount);

  _myserver->on("/enableavrprog.json", HTTP_POST, DIYBMSServer::enableAVRprog);
  _myserver->on("/disableavrprog.json", HTTP_POST, DIYBMSServer::disableAVRprog);

  _myserver->on("/avrprog.json", HTTP_POST, DIYBMSServer::avrProgrammer);
  

  //Current monitor services/settings
  _myserver->on("/savers485settings.json", HTTP_POST, DIYBMSServer::saveRS485Settings);
  _myserver->on("/savecurrentmon.json", HTTP_POST, DIYBMSServer::saveCurrentMonSettings);
  _myserver->on("/savecmbasic.json", HTTP_POST, DIYBMSServer::saveCurrentMonBasic);
  _myserver->on("/savecmadvanced.json", HTTP_POST, DIYBMSServer::saveCurrentMonAdvanced);
  _myserver->on("/savecmrelay.json", HTTP_POST, DIYBMSServer::saveCurrentMonRelay);
  //Victron stuff
  _myserver->on("/savevictron.json", HTTP_POST, DIYBMSServer::saveVictron);

  _myserver->onNotFound(DIYBMSServer::handleNotFound);
  _myserver->begin();

  ESP_LOGI(TAG, "Start Web Server complete");
}
